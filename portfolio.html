<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Portfolio</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }

        #canvas-container:active {
            cursor: grabbing;
        }

        /* Loading Screen */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
        }

        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            color: #fff;
            margin-top: 20px;
            font-size: 18px;
        }

        /* Modal Overlay */
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #modal-overlay.active {
            display: flex;
            opacity: 1;
        }

        .modal-card {
            background: linear-gradient(135deg, #2d3561 0%, #1f2645 100%);
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            transform: scale(0.9);
            transition: transform 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #modal-overlay.active .modal-card {
            transform: scale(1);
        }

        .modal-close {
            float: right;
            font-size: 28px;
            font-weight: bold;
            color: #fff;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            width: 30px;
            height: 30px;
            line-height: 30px;
            text-align: center;
            transition: transform 0.2s ease;
        }

        .modal-close:hover {
            transform: rotate(90deg);
            color: #00d4ff;
        }

        .modal-title {
            color: #00d4ff;
            font-size: 32px;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .modal-description {
            color: #e0e0e0;
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .modal-technologies {
            margin-bottom: 25px;
        }

        .tech-label {
            color: #00d4ff;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 10px;
            display: block;
        }

        .tech-tag {
            display: inline-block;
            background: rgba(0, 212, 255, 0.2);
            color: #00d4ff;
            padding: 6px 14px;
            border-radius: 20px;
            margin: 5px 5px 5px 0;
            font-size: 13px;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }

        .modal-screenshot {
            width: 100%;
            border-radius: 10px;
            margin-bottom: 25px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .modal-button {
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            color: #fff;
            border: none;
            padding: 14px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-right: 10px;
            text-decoration: none;
            display: inline-block;
        }

        .modal-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 212, 255, 0.3);
        }

        .modal-button.secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .modal-button.secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 10px 25px rgba(255, 255, 255, 0.1);
        }

        /* Instructions */
        #instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        @media (max-width: 768px) {
            .modal-card {
                padding: 25px;
            }

            .modal-title {
                font-size: 24px;
            }

            #instructions {
                font-size: 12px;
                padding: 10px 15px;
                bottom: 10px;
            }
        }

        /* Scrollbar styling for modal */
        .modal-card::-webkit-scrollbar {
            width: 8px;
        }

        .modal-card::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .modal-card::-webkit-scrollbar-thumb {
            background: rgba(0, 212, 255, 0.5);
            border-radius: 10px;
        }

        .modal-card::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 212, 255, 0.7);
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loader"></div>
        <div class="loading-text">Loading Portfolio...</div>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Instructions -->
    <div id="instructions">
        üñ±Ô∏è Drag to rotate ‚Ä¢ üñ±Ô∏è Click monitors to view projects ‚Ä¢ ‚å®Ô∏è Tab + Enter for keyboard navigation
    </div>

    <!-- Modal Overlay -->
    <div id="modal-overlay">
        <div class="modal-card">
            <button class="modal-close" id="modal-close">&times;</button>
            <h2 class="modal-title" id="modal-title"></h2>
            <p class="modal-description" id="modal-description"></p>
            <div class="modal-technologies">
                <span class="tech-label">Technologies:</span>
                <div id="modal-tech-tags"></div>
            </div>
            <img class="modal-screenshot" id="modal-screenshot" src="" alt="Project screenshot" style="display: none;">
            <div>
                <a class="modal-button" id="modal-view-button" href="#" target="_blank">View Project ‚Üí</a>
                <button class="modal-button secondary" id="modal-close-button">Close</button>
            </div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- GLTFLoader for loading character model -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // ==============================================
        // PROJECT DATA - Easy to update!
        // ==============================================
        const projects = [
            {
                id: 1,
                title: "Neural Network Visualizer",
                description: "An interactive 3D visualization of neural network architectures with real-time training animation. Explore how data flows through layers and watch the network learn.",
                technologies: ["Three.js", "TensorFlow.js", "WebGL"],
                liveUrl: "https://example.com/neural-viz",
                thumbnail: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='300'%3E%3Crect fill='%231a1a2e' width='400' height='300'/%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' fill='%2300d4ff' font-size='24' font-family='Arial'%3ENeural Net%3C/text%3E%3C/svg%3E",
                monitorPosition: { x: -2.5, y: 1.1, z: -1.3 }  // Back left
            },
            {
                id: 2,
                title: "Particle Physics Sandbox",
                description: "A WebGL-powered particle physics playground where you can experiment with gravity, collision, and forces in real-time. Includes preset simulations and custom parameter controls.",
                technologies: ["WebGL", "GLSL", "JavaScript"],
                liveUrl: "https://example.com/particles",
                thumbnail: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='300'%3E%3Crect fill='%231a1a2e' width='400' height='300'/%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' fill='%2300d4ff' font-size='24' font-family='Arial'%3EParticles%3C/text%3E%3C/svg%3E",
                monitorPosition: { x: -1, y: 1.1, z: -1.3 }  // Back center-left
            },
            {
                id: 3,
                title: "Generative Art Gallery",
                description: "A curated collection of generative art pieces created with algorithms. Each piece is unique and generated in real-time using mathematical functions and random seeds.",
                technologies: ["Canvas API", "P5.js", "React"],
                liveUrl: "https://example.com/gen-art",
                thumbnail: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='300'%3E%3Crect fill='%231a1a2e' width='400' height='300'/%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' fill='%2300d4ff' font-size='24' font-family='Arial'%3EGen Art%3C/text%3E%3C/svg%3E",
                monitorPosition: { x: 1, y: 1.1, z: -1.3 }  // Back center-right
            },
            {
                id: 4,
                title: "Sound Wave Sculptor",
                description: "Create beautiful 3D forms from audio input. Upload music or use your microphone to generate real-time sculptural visualizations based on frequency and amplitude data.",
                technologies: ["Web Audio API", "Three.js", "Tone.js"],
                liveUrl: "https://example.com/sound-sculpt",
                thumbnail: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='300'%3E%3Crect fill='%231a1a2e' width='400' height='300'/%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' fill='%2300d4ff' font-size='24' font-family='Arial'%3ESound Wave%3C/text%3E%3C/svg%3E",
                monitorPosition: { x: 2.5, y: 1.1, z: -1.3 }  // Back right
            },
            {
                id: 5,
                title: "Shader Playground",
                description: "An interactive GLSL shader editor with live preview. Experiment with fragment and vertex shaders, explore preset effects, and create mesmerizing visual effects.",
                technologies: ["GLSL", "WebGL", "CodeMirror"],
                liveUrl: "https://example.com/shaders",
                thumbnail: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='300'%3E%3Crect fill='%231a1a2e' width='400' height='300'/%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' fill='%2300d4ff' font-size='24' font-family='Arial'%3EShaders%3C/text%3E%3C/svg%3E",
                monitorPosition: { x: -2.9, y: 1.1, z: 0.8 }  // Left side
            },
            {
                id: 6,
                title: "Fractal Explorer",
                description: "Dive deep into the infinite beauty of fractals. Navigate through Mandelbrot and Julia sets with smooth zooming, color customization, and high-resolution rendering.",
                technologies: ["WebGL", "GLSL", "TypeScript"],
                liveUrl: "https://example.com/fractals",
                thumbnail: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='300'%3E%3Crect fill='%231a1a2e' width='400' height='300'/%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' fill='%2300d4ff' font-size='24' font-family='Arial'%3EFractals%3C/text%3E%3C/svg%3E",
                monitorPosition: { x: 2.9, y: 1.1, z: 0.8 }  // Right side
            }
        ];

        // ==============================================
        // SCENE SETUP
        // ==============================================
        let scene, camera, renderer, controls;
        let monitors = [];
        let character;
        let mixer;  // Animation mixer for GLB animations
        let idleAction, clappingAction;  // Specific animations
        let raycaster, mouse;
        let hoveredMonitor = null;
        let selectedMonitorIndex = -1;
        let clock;

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a15); // Very dark blue/black
            scene.fog = new THREE.Fog(0x0a0a15, 8, 20);

            // Camera - Behind character looking at monitor wall
            camera = new THREE.PerspectiveCamera(
                75,  // Wider FOV for immersive feel
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            // Position behind character (larger Z), looking toward wall (toward -Z)
            camera.position.set(0.5, 2.5, 5.5);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Controls - loaded after Three.js
            loadOrbitControls();

            // Raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Clock for animations
            clock = new THREE.Clock();

            // Lighting
            setupLighting();

            // Load character FIRST, then create everything else based on its dimensions
            loadCharacterAndSetup();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('click', onMouseClick);
            window.addEventListener('keydown', onKeyDown);

            // Start animation
            animate();
        }

        function loadOrbitControls() {
            // OrbitControls - inline minimal version
            THREE.OrbitControls = function(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;

                this.enabled = true;
                this.target = new THREE.Vector3();

                this.minDistance = 5;
                this.maxDistance = 15;
                this.minPolarAngle = 0;
                this.maxPolarAngle = Math.PI / 2;
                this.minAzimuthAngle = -Infinity;
                this.maxAzimuthAngle = Infinity;

                this.enableDamping = true;
                this.dampingFactor = 0.05;

                this.rotateSpeed = 0.5;

                const scope = this;
                const spherical = new THREE.Spherical();
                const sphericalDelta = new THREE.Spherical();
                let scale = 1;

                const rotateStart = new THREE.Vector2();
                const rotateEnd = new THREE.Vector2();
                const rotateDelta = new THREE.Vector2();

                let state = -1;
                const STATE = { NONE: -1, ROTATE: 0 };

                function onMouseDown(event) {
                    if (!scope.enabled) return;
                    event.preventDefault();
                    rotateStart.set(event.clientX, event.clientY);
                    state = STATE.ROTATE;
                    scope.domElement.addEventListener('mousemove', onMouseMove);
                    scope.domElement.addEventListener('mouseup', onMouseUp);
                }

                function onMouseMove(event) {
                    if (!scope.enabled) return;
                    event.preventDefault();
                    rotateEnd.set(event.clientX, event.clientY);
                    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
                    const element = scope.domElement;
                    sphericalDelta.theta -= 2 * Math.PI * rotateDelta.x / element.clientHeight;
                    sphericalDelta.phi -= 2 * Math.PI * rotateDelta.y / element.clientHeight;
                    rotateStart.copy(rotateEnd);
                }

                function onMouseUp(event) {
                    if (!scope.enabled) return;
                    scope.domElement.removeEventListener('mousemove', onMouseMove);
                    scope.domElement.removeEventListener('mouseup', onMouseUp);
                    state = STATE.NONE;
                }

                function onMouseWheel(event) {
                    if (!scope.enabled) return;
                    event.preventDefault();
                    event.stopPropagation();
                    if (event.deltaY < 0) {
                        scale /= 0.95;
                    } else if (event.deltaY > 0) {
                        scale *= 0.95;
                    }
                }

                this.update = function() {
                    const offset = new THREE.Vector3();
                    const quat = new THREE.Quaternion().setFromUnitVectors(camera.up, new THREE.Vector3(0, 1, 0));
                    const quatInverse = quat.clone().invert();
                    const lastPosition = new THREE.Vector3();
                    const lastQuaternion = new THREE.Quaternion();

                    return function update() {
                        const position = scope.camera.position;
                        offset.copy(position).sub(scope.target);
                        offset.applyQuaternion(quat);
                        spherical.setFromVector3(offset);

                        if (scope.enableDamping) {
                            spherical.theta += sphericalDelta.theta * scope.dampingFactor;
                            spherical.phi += sphericalDelta.phi * scope.dampingFactor;
                            sphericalDelta.theta *= (1 - scope.dampingFactor);
                            sphericalDelta.phi *= (1 - scope.dampingFactor);
                        } else {
                            spherical.theta += sphericalDelta.theta;
                            spherical.phi += sphericalDelta.phi;
                            sphericalDelta.set(0, 0, 0);
                        }

                        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
                        spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta));
                        spherical.makeSafe();
                        spherical.radius *= scale;
                        spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));

                        offset.setFromSpherical(spherical);
                        offset.applyQuaternion(quatInverse);
                        position.copy(scope.target).add(offset);
                        scope.camera.lookAt(scope.target);

                        scale = 1;

                        if (lastPosition.distanceToSquared(scope.camera.position) > 0.00001 ||
                            8 * (1 - lastQuaternion.dot(scope.camera.quaternion)) > 0.00001) {
                            lastPosition.copy(scope.camera.position);
                            lastQuaternion.copy(scope.camera.quaternion);
                            return true;
                        }
                        return false;
                    };
                }();

                this.domElement.addEventListener('mousedown', onMouseDown);
                this.domElement.addEventListener('wheel', onMouseWheel, { passive: false });
            };

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            // Target point at center of monitor wall (z=0 where monitors are)
            controls.target.set(0, 1.8, 0);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 3;
            controls.maxDistance = 10;
            controls.maxPolarAngle = Math.PI / 2.2;  // Can't go below floor
            // Restrict azimuthal angle to prevent going behind monitors
            controls.minAzimuthAngle = -Math.PI / 4;  // -45 degrees
            controls.maxAzimuthAngle = Math.PI / 4;   // +45 degrees
            controls.update();
        }

        function loadCharacterAndSetup() {
            const loader = new THREE.GLTFLoader();

            loader.load(
                './assets/character.glb',
                // Success callback - character loaded, now measure and build scene
                function(gltf) {
                    character = gltf.scene;

                    // MEASURE the character's actual dimensions
                    const box = new THREE.Box3().setFromObject(character);
                    const size = box.getSize(new THREE.Vector3());
                    const characterHeight = size.y;

                    console.log('Character loaded - Height:', characterHeight);

                    // CALCULATE all positions based on character
                    const deskHeight = characterHeight * 0.6;  // Desk at waist height
                    const deskSurfaceY = deskHeight + 0.1;     // Top of desk surface

                    console.log('Calculated desk height:', deskHeight);
                    console.log('Desk surface at:', deskSurfaceY);

                    // Scale character to proper size (needs to be larger than monitors/objects)
                    const targetHeight = 3.0;  // Increased from 1.8 to make character bigger
                    const scale = targetHeight / characterHeight;
                    character.scale.set(scale, scale, scale);

                    // Recalculate after scaling
                    const scaledHeight = targetHeight;
                    const finalDeskHeight = scaledHeight * 0.6;
                    const deskThickness = 0.05;  // Thinner desk
                    const finalDeskSurfaceY = finalDeskHeight + (deskThickness / 2);

                    console.log('After scaling - Character height:', scaledHeight);
                    console.log('Final desk height:', finalDeskHeight);
                    console.log('Final desk surface:', finalDeskSurfaceY);

                    // Position character between camera and monitors, facing the wall
                    character.position.set(0, 0, 2.5);  // In front of wall
                    character.rotation.y = Math.PI;  // Face toward wall (negative Z direction)

                    // Enable shadows and find head/body for animation
                    let headMesh = null;
                    let bodyMesh = null;

                    character.traverse(function(node) {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                            if (node.material) {
                                node.material.roughness = Math.max(node.material.roughness || 0.5, 0.7);
                                node.material.metalness = Math.min(node.material.metalness || 0.1, 0.2);
                            }

                            // Try to identify head and body meshes by name
                            const nodeName = node.name.toLowerCase();
                            if (nodeName.includes('head') || nodeName.includes('skull')) {
                                headMesh = node;
                            } else if (nodeName.includes('body') || nodeName.includes('torso') || nodeName.includes('spine')) {
                                bodyMesh = node;
                            }
                        }
                    });

                    // Set up animation mixer for GLB animations
                    if (gltf.animations && gltf.animations.length > 0) {
                        mixer = new THREE.AnimationMixer(character);

                        console.log('=== ALL ANIMATIONS IN GLB ===');
                        gltf.animations.forEach((clip, index) => {
                            console.log(`  [${index}] "${clip.name}" - ${clip.duration.toFixed(2)}s`);
                        });
                        console.log('=============================');

                        // Select animations by index (more reliable than name matching)
                        // Testing different indices - [1] might be the actual clapping
                        const IDLE_ANIMATION_INDEX = 2;     // Man_Idle (4.17s)
                        const CLAPPING_ANIMATION_INDEX = 1; // Trying index 1 for clapping

                        if (gltf.animations[IDLE_ANIMATION_INDEX]) {
                            idleAction = mixer.clipAction(gltf.animations[IDLE_ANIMATION_INDEX]);
                            idleAction.loop = THREE.LoopRepeat;
                            console.log(`Using animation [${IDLE_ANIMATION_INDEX}] "${gltf.animations[IDLE_ANIMATION_INDEX].name}" as IDLE (looping)`);
                        }

                        if (gltf.animations[CLAPPING_ANIMATION_INDEX]) {
                            clappingAction = mixer.clipAction(gltf.animations[CLAPPING_ANIMATION_INDEX]);
                            clappingAction.loop = THREE.LoopRepeat;  // Loop for debugging
                            clappingAction.clampWhenFinished = false;
                            console.log(`Using animation [${CLAPPING_ANIMATION_INDEX}] "${gltf.animations[CLAPPING_ANIMATION_INDEX].name}" as CLAPPING (looping for debug)`);
                        }

                        // Start the idle animation immediately
                        if (idleAction) {
                            idleAction.play();
                            console.log('‚úì Started idle animation');
                        } else {
                            console.warn('‚ö† No idle animation found!');
                        }

                        if (!clappingAction) {
                            console.warn('‚ö† No clapping animation found!');
                        }
                    } else {
                        console.warn('No animations found in GLB model');
                    }

                    // Store references for fallback if no animations
                    character.userData.head = headMesh || character;
                    character.userData.body = bodyMesh || character;
                    character.userData.isGLBModel = true;
                    character.userData.hasAnimations = (idleAction || clappingAction);

                    console.log('GLB character loaded:');
                    console.log('  Head mesh found:', headMesh ? headMesh.name : 'Using entire character');
                    console.log('  Body mesh found:', bodyMesh ? bodyMesh.name : 'Using entire character');

                    scene.add(character);

                    // NO ANIMATIONS by default - will play once every 60 seconds
                    console.log('Character positioned at z=2.5, facing monitor wall at z=0');

                    // Create surveillance room setup
                    createFloor();
                    createMonitorWall();
                    createBackWall();
                    createDome();

                    // Hide loading screen
                    setTimeout(() => {
                        document.getElementById('loading-screen').classList.add('hidden');
                    }, 500);
                },
                // Progress callback
                function(xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                // Error callback - use fallback
                function(error) {
                    console.error('Error loading character model:', error);

                    if (window.location.protocol === 'file:') {
                        console.error('‚ùå CORS Error: Cannot load GLB files using file:// protocol');
                        console.info('üí° Solution: Run a local web server instead:');
                        console.info('   Option 1: python3 -m http.server 8000');
                        console.info('   Option 2: npx http-server');
                        console.info('   Then visit: http://localhost:8000/portfolio.html');
                    }

                    console.warn('Creating fallback placeholder character');
                    createFallbackCharacterAndSetup();
                }
            );
        }

        function createFallbackCharacterAndSetup() {
            // Fallback: Simple placeholder if GLB fails to load (scaled to 3.0 units tall)
            character = new THREE.Group();

            const bodyGeometry = new THREE.BoxGeometry(1.2, 1.8, 1.0);  // Scaled up
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x2d7f8f,
                roughness: 0.85,
                metalness: 0.0
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.9;  // Half of body height
            body.castShadow = true;
            character.add(body);

            const headGeometry = new THREE.SphereGeometry(0.65, 16, 16);  // Scaled up
            const headMaterial = new THREE.MeshStandardMaterial({
                color: 0xffcfa0,
                roughness: 0.9,
                metalness: 0.0
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.4;  // Body height (1.8) + head radius (0.65) - slight overlap
            head.castShadow = true;
            character.add(head);

            character.position.set(0, 0, 2.5);  // In front of wall
            character.rotation.y = Math.PI;  // Face toward wall (negative Z direction)
            scene.add(character);

            character.userData.head = head;
            character.userData.body = body;

            console.log('Fallback character created - height: 3.0 units');
            console.log('Position: z=2.5, facing monitor wall at z=0');

            // Create surveillance room setup
            createFloor();
            createMonitorWall();
            createBackWall();
            createDome();

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading-screen').classList.add('hidden');
            }, 500);
        }

        function setupLighting() {
            // Very dim ambient light - dark surveillance room
            const ambientLight = new THREE.AmbientLight(0x1a1a2e, 0.2);
            scene.add(ambientLight);

            // Subtle blue directional light from monitors (very dim)
            const monitorLight = new THREE.DirectionalLight(0x00d4ff, 0.3);
            monitorLight.position.set(0, 2, 0.5);  // At monitor wall position
            monitorLight.castShadow = true;
            monitorLight.shadow.mapSize.width = 1024;
            monitorLight.shadow.mapSize.height = 1024;
            scene.add(monitorLight);

            // Rim light on character from monitor glow
            const rimLight = new THREE.PointLight(0x0099cc, 0.5);
            rimLight.position.set(0, 1.5, 0);  // At monitor wall to light character
            scene.add(rimLight);
        }

        function createFloor() {
            // Dark floor with subtle grid pattern
            const floorGeometry = new THREE.PlaneGeometry(30, 30);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x0d0d1a, // Very dark blue/black
                roughness: 0.95,
                metalness: 0.1
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Optional: Add subtle grid lines
            const gridHelper = new THREE.GridHelper(30, 30, 0x1a1a2e, 0x0f0f1a);
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
        }

        function createBackWall() {
            // Wall behind monitors
            const wallGeometry = new THREE.PlaneGeometry(15, 8);
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x0a0a15, // Very dark to blend with background
                roughness: 0.9,
                metalness: 0.0
            });
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.set(0, 2, -0.5);  // Behind monitor wall (monitors at z=0)
            wall.receiveShadow = true;
            scene.add(wall);
        }

        function createDome() {
            // Create hemisphere/dome to hide floor edges and create enclosed space
            const domeGeometry = new THREE.SphereGeometry(25, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
            const domeMaterial = new THREE.MeshStandardMaterial({
                color: 0x0a0a15, // Match background color
                side: THREE.BackSide,  // Render inside of sphere
                roughness: 1.0,
                metalness: 0.0
            });
            const dome = new THREE.Mesh(domeGeometry, domeMaterial);
            dome.position.set(0, 0, 0);
            dome.rotation.y = Math.PI; // Rotate to align properly
            scene.add(dome);
        }

        function createMonitorWall() {
            // Create 2x3 grid of large TV-style monitors on wall
            // Grid: 2 rows, 3 columns
            const monitorWidth = 2.4;   // Large TV size (16:9 ratio)
            const monitorHeight = 1.35;
            const gap = 0.15;  // Small gap between monitors
            const wallDistance = 0;  // Monitors AT the wall (z=0)
            const baseHeight = 1.2;  // Bottom row starts here

            const rows = 2;
            const cols = 3;

            let monitorIndex = 0;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (monitorIndex >= projects.length) break;

                    const project = projects[monitorIndex];
                    const monitor = createLargeTVMonitor(project, monitorWidth, monitorHeight);

                    // Calculate position in grid
                    const xPos = (col - 1) * (monitorWidth + gap);  // Center at col=1
                    const yPos = baseHeight + row * (monitorHeight + gap);

                    monitor.position.set(xPos, yPos, wallDistance);

                    // No rotation needed - monitors naturally face toward negative Z (toward camera/character)

                    // Add to userData (don't replace - createLargeTVMonitor already set screen, glow, frame, light)
                    monitor.userData.projectId = project.id;
                    monitor.userData.projectIndex = monitorIndex;
                    monitor.userData.originalY = yPos;
                    monitor.userData.originalEmissive = 0.8;
                    monitor.userData.isHovered = false;
                    monitor.userData.isStatic = false;

                    monitors.push(monitor);
                    scene.add(monitor);
                    monitorIndex++;
                }
            }

            console.log(`Created ${monitors.length} monitors in 2x3 wall grid`);
        }

        function createLargeTVMonitor(project, width, height) {
            const monitor = new THREE.Group();

            // Thin bezel/frame
            const frameThickness = 0.05;
            const frameGeometry = new THREE.BoxGeometry(
                width + 0.1,
                height + 0.1,
                frameThickness
            );
            const frameMaterial = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a, // Almost black
                roughness: 0.6,
                metalness: 0.3
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.castShadow = true;
            monitor.add(frame);

            // Screen with project thumbnail
            const screenGeometry = new THREE.PlaneGeometry(width, height);
            const textureLoader = new THREE.TextureLoader();
            const texture = textureLoader.load(project.thumbnail);

            const screenMaterial = new THREE.MeshStandardMaterial({
                map: texture,
                emissive: 0x00aaff,  // Cyan/blue glow
                emissiveIntensity: 0.8,  // Strong glow - main light source
                roughness: 0.1,
                metalness: 0.1
            });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.z = frameThickness / 2 + 0.01;
            monitor.add(screen);

            // Glow effect for hover
            const glowGeometry = new THREE.PlaneGeometry(width + 0.2, height + 0.2);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x00d4ff,
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.z = frameThickness / 2 + 0.02;
            monitor.add(glow);

            // Point light for each monitor (contributes to room lighting)
            const monitorLight = new THREE.PointLight(0x00aaff, 1.5, 5);
            monitorLight.position.z = 0.5;
            monitor.add(monitorLight);

            // Store references
            monitor.userData.screen = screen;
            monitor.userData.glow = glow;
            monitor.userData.frame = frame;
            monitor.userData.light = monitorLight;

            return monitor;
        }

        // ==============================================
        // ANIMATION & INTERACTION
        // ==============================================
        let lastAnimationTime = 0;
        const ANIMATION_INTERVAL = 60000;  // 60 seconds
        let lastStaticTime = 0;
        let staticMonitor = null;
        let staticDuration = 0;
        let manualAnimationTriggered = false;
        let manualAnimationStartTime = 0;

        function triggerCharacterAnimation() {
            // Manually trigger character animation
            manualAnimationTriggered = true;
            manualAnimationStartTime = Date.now();
            console.log('Character animation triggered by click');
        }

        function playCharacterAnimation() {
            if (clappingAction && idleAction) {
                console.log('Switching to CLAPPING animation');
                console.log('  Duration:', clappingAction.getClip().duration.toFixed(2), 'seconds');

                // Stop idle action and start clapping with proper weight management
                idleAction.enabled = true;
                clappingAction.enabled = true;

                // Set initial weights
                idleAction.setEffectiveWeight(1);
                clappingAction.setEffectiveWeight(0);

                // Reset and play clapping from start
                clappingAction.reset();
                clappingAction.play();

                // Manual crossfade: transition weights over time
                const fadeDuration = 0.3; // seconds
                const fadeSteps = 30; // steps for smooth fade
                const fadeInterval = (fadeDuration * 1000) / fadeSteps;
                let fadeStep = 0;

                const fadeToClapping = setInterval(() => {
                    fadeStep++;
                    const progress = fadeStep / fadeSteps;

                    idleAction.setEffectiveWeight(1 - progress);
                    clappingAction.setEffectiveWeight(progress);

                    if (fadeStep >= fadeSteps) {
                        clearInterval(fadeToClapping);
                        // Ensure final states are correct
                        idleAction.setEffectiveWeight(0);
                        clappingAction.setEffectiveWeight(1);
                    }
                }, fadeInterval);

                // After clapping finishes + hold time, fade back to idle
                const clappingDuration = clappingAction.getClip().duration * 1000;  // Convert to ms
                const holdTime = 10000;  // Hold completed animation for 10s to debug
                setTimeout(() => {
                    if (clappingAction && idleAction) {
                        console.log('Switching back to IDLE animation');

                        // Reset and play idle
                        idleAction.reset();
                        idleAction.play();

                        // Manual crossfade back to idle
                        const backFadeDuration = 0.5; // seconds
                        const backFadeSteps = 30;
                        const backFadeInterval = (backFadeDuration * 1000) / backFadeSteps;
                        let backFadeStep = 0;

                        const fadeToIdle = setInterval(() => {
                            backFadeStep++;
                            const progress = backFadeStep / backFadeSteps;

                            clappingAction.setEffectiveWeight(1 - progress);
                            idleAction.setEffectiveWeight(progress);

                            if (backFadeStep >= backFadeSteps) {
                                clearInterval(fadeToIdle);
                                // Ensure final states are correct
                                clappingAction.setEffectiveWeight(0);
                                clappingAction.enabled = false;
                                idleAction.setEffectiveWeight(1);
                            }
                        }, backFadeInterval);
                    }
                }, clappingDuration + holdTime);

            } else if (clappingAction) {
                // Only have clapping, no idle
                clappingAction.reset();
                clappingAction.play();
                console.log('Playing CLAPPING animation (no idle)');
            } else {
                console.warn('No clapping animation available!');
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();
            const currentTime = Date.now();
            const delta = clock.getDelta();

            // Update animation mixer for GLB animations
            if (mixer) {
                mixer.update(delta);
            }

            // Character animation trigger - plays ONCE every 60 seconds OR when clicked
            if (character) {
                // Check for manual trigger (from click)
                if (manualAnimationTriggered) {
                    manualAnimationTriggered = false;  // Reset immediately
                    playCharacterAnimation();
                }
                // Check for automatic 60-second trigger
                else if (currentTime - lastAnimationTime > ANIMATION_INTERVAL) {
                    lastAnimationTime = currentTime;
                    playCharacterAnimation();
                }
            }

            // Random static flicker on monitors
            // Check every frame with low probability
            if (staticMonitor === null && Math.random() < 0.005) {  // ~0.5% chance per frame
                // Pick random monitor for static
                const randomIndex = Math.floor(Math.random() * monitors.length);
                staticMonitor = monitors[randomIndex];
                staticMonitor.userData.isStatic = true;
                staticDuration = 1000 + Math.random() * 1000;  // 1-2 seconds
                lastStaticTime = currentTime;

                // Show static pattern (for now, just dim the screen significantly)
                staticMonitor.userData.screen.material.emissiveIntensity = 0.3;
                staticMonitor.userData.screen.material.emissive.setHex(0xffffff);  // White static
            }

            // Clear static after duration
            if (staticMonitor && currentTime - lastStaticTime > staticDuration) {
                staticMonitor.userData.isStatic = false;
                staticMonitor.userData.screen.material.emissiveIntensity = staticMonitor.userData.originalEmissive;
                staticMonitor.userData.screen.material.emissive.setHex(0x00aaff);  // Back to cyan
                staticMonitor = null;
            }

            // Monitor hover animations
            monitors.forEach(monitor => {
                // Skip if monitor or required properties don't exist
                if (!monitor || !monitor.userData || !monitor.userData.glow || !monitor.userData.screen) {
                    return;
                }

                // Don't animate if showing static
                if (monitor.userData.isStatic) {
                    return;
                }

                const targetGlowOpacity = monitor.userData.isHovered ? 0.3 : 0;
                monitor.userData.glow.material.opacity +=
                    (targetGlowOpacity - monitor.userData.glow.material.opacity) * 0.1;

                const targetEmissive = monitor.userData.isHovered ? 1.0 : monitor.userData.originalEmissive;
                monitor.userData.screen.material.emissiveIntensity +=
                    (targetEmissive - monitor.userData.screen.material.emissiveIntensity) * 0.1;
            });

            // Update controls
            if (controls) controls.update();

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update raycaster
            raycaster.setFromCamera(mouse, camera);

            // Check for character hover first
            if (character) {
                const characterIntersects = raycaster.intersectObject(character, true);
                if (characterIntersects.length > 0) {
                    document.body.style.cursor = 'pointer';
                    // Reset monitor hover states
                    monitors.forEach(monitor => {
                        monitor.userData.isHovered = false;
                    });
                    hoveredMonitor = null;
                    return;
                }
            }

            // Check for intersections with monitors
            const intersects = raycaster.intersectObjects(monitors, true);

            // Reset all hover states
            monitors.forEach(monitor => {
                monitor.userData.isHovered = false;
            });

            // Set hover state for intersected monitor
            if (intersects.length > 0) {
                let object = intersects[0].object;
                while (object.parent && !monitors.includes(object.parent)) {
                    object = object.parent;
                }
                if (object.parent && monitors.includes(object.parent)) {
                    object.parent.userData.isHovered = true;
                    document.body.style.cursor = 'pointer';
                    hoveredMonitor = object.parent;
                } else {
                    document.body.style.cursor = 'default';
                    hoveredMonitor = null;
                }
            } else {
                document.body.style.cursor = 'default';
                hoveredMonitor = null;
            }
        }

        function onMouseClick(event) {
            // Don't trigger if clicking on modal
            if (event.target.closest('#modal-overlay')) return;

            // Check if character was clicked
            raycaster.setFromCamera(mouse, camera);

            if (character) {
                const characterIntersects = raycaster.intersectObject(character, true);
                if (characterIntersects.length > 0) {
                    // Character was clicked - trigger animation
                    triggerCharacterAnimation();
                    return;
                }
            }

            // Check if monitor was clicked
            if (hoveredMonitor) {
                const projectIndex = hoveredMonitor.userData.projectIndex;
                openModal(projectIndex);
            }
        }

        function onKeyDown(event) {
            // Tab key for navigation
            if (event.key === 'Tab') {
                event.preventDefault();
                selectedMonitorIndex = (selectedMonitorIndex + 1) % monitors.length;

                // Reset all hover states
                monitors.forEach(monitor => {
                    monitor.userData.isHovered = false;
                });

                // Set selected monitor as hovered
                monitors[selectedMonitorIndex].userData.isHovered = true;
                hoveredMonitor = monitors[selectedMonitorIndex];
            }

            // Enter key to open modal
            if (event.key === 'Enter' && hoveredMonitor) {
                const projectIndex = hoveredMonitor.userData.projectIndex;
                openModal(projectIndex);
            }

            // Escape key to close modal
            if (event.key === 'Escape') {
                closeModal();
            }
        }

        // ==============================================
        // MODAL SYSTEM
        // ==============================================
        function openModal(projectIndex) {
            const project = projects[projectIndex];

            // Populate modal
            document.getElementById('modal-title').textContent = project.title;
            document.getElementById('modal-description').textContent = project.description;
            document.getElementById('modal-view-button').href = project.liveUrl;

            // Add technology tags
            const techTagsContainer = document.getElementById('modal-tech-tags');
            techTagsContainer.innerHTML = '';
            project.technologies.forEach(tech => {
                const tag = document.createElement('span');
                tag.className = 'tech-tag';
                tag.textContent = tech;
                techTagsContainer.appendChild(tag);
            });

            // Show/hide screenshot
            const screenshot = document.getElementById('modal-screenshot');
            if (project.screenshot) {
                screenshot.src = project.screenshot;
                screenshot.style.display = 'block';
            } else {
                screenshot.style.display = 'none';
            }

            // Show modal
            const modalOverlay = document.getElementById('modal-overlay');
            modalOverlay.classList.add('active');

            // Disable controls while modal is open
            if (controls) controls.enabled = false;
        }

        function closeModal() {
            const modalOverlay = document.getElementById('modal-overlay');
            modalOverlay.classList.remove('active');

            // Re-enable controls
            if (controls) controls.enabled = true;

            // Reset hover state
            monitors.forEach(monitor => {
                monitor.userData.isHovered = false;
            });
            hoveredMonitor = null;
            selectedMonitorIndex = -1;
        }

        // Modal close button handlers
        document.getElementById('modal-close').addEventListener('click', closeModal);
        document.getElementById('modal-close-button').addEventListener('click', closeModal);
        document.getElementById('modal-overlay').addEventListener('click', function(event) {
            if (event.target === this) {
                closeModal();
            }
        });

        // ==============================================
        // INITIALIZE
        // ==============================================
        init();
    </script>
</body>
</html>