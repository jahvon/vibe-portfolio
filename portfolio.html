<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Portfolio</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }

        #canvas-container:active {
            cursor: grabbing;
        }

        /* Loading Screen */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
        }

        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            color: #fff;
            margin-top: 20px;
            font-size: 18px;
        }

        /* Modal Overlay */
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #modal-overlay.active {
            display: flex;
            opacity: 1;
        }

        .modal-card {
            background: linear-gradient(135deg, #2d3561 0%, #1f2645 100%);
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            transform: scale(0.9);
            transition: transform 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #modal-overlay.active .modal-card {
            transform: scale(1);
        }

        .modal-close {
            float: right;
            font-size: 28px;
            font-weight: bold;
            color: #fff;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            width: 30px;
            height: 30px;
            line-height: 30px;
            text-align: center;
            transition: transform 0.2s ease;
        }

        .modal-close:hover {
            transform: rotate(90deg);
            color: #00d4ff;
        }

        .modal-title {
            color: #00d4ff;
            font-size: 32px;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .modal-description {
            color: #e0e0e0;
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .modal-technologies {
            margin-bottom: 25px;
        }

        .tech-label {
            color: #00d4ff;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 10px;
            display: block;
        }

        .tech-tag {
            display: inline-block;
            background: rgba(0, 212, 255, 0.2);
            color: #00d4ff;
            padding: 6px 14px;
            border-radius: 20px;
            margin: 5px 5px 5px 0;
            font-size: 13px;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }

        .modal-screenshot {
            width: 100%;
            border-radius: 10px;
            margin-bottom: 25px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .modal-button {
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            color: #fff;
            border: none;
            padding: 14px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-right: 10px;
            text-decoration: none;
            display: inline-block;
        }

        .modal-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 212, 255, 0.3);
        }

        .modal-button.secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .modal-button.secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 10px 25px rgba(255, 255, 255, 0.1);
        }

        /* Instructions */
        #instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        @media (max-width: 768px) {
            .modal-card {
                padding: 25px;
            }

            .modal-title {
                font-size: 24px;
            }

            #instructions {
                font-size: 12px;
                padding: 10px 15px;
                bottom: 10px;
            }
        }

        /* Scrollbar styling for modal */
        .modal-card::-webkit-scrollbar {
            width: 8px;
        }

        .modal-card::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .modal-card::-webkit-scrollbar-thumb {
            background: rgba(0, 212, 255, 0.5);
            border-radius: 10px;
        }

        .modal-card::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 212, 255, 0.7);
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loader"></div>
        <div class="loading-text">Loading Portfolio...</div>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Instructions -->
    <div id="instructions">
        üñ±Ô∏è Drag to rotate ‚Ä¢ üñ±Ô∏è Click monitors to view projects ‚Ä¢ ‚å®Ô∏è Tab + Enter for keyboard navigation
    </div>

    <!-- Modal Overlay -->
    <div id="modal-overlay">
        <div class="modal-card">
            <button class="modal-close" id="modal-close">&times;</button>
            <h2 class="modal-title" id="modal-title"></h2>
            <p class="modal-description" id="modal-description"></p>
            <div class="modal-technologies">
                <span class="tech-label">Technologies:</span>
                <div id="modal-tech-tags"></div>
            </div>
            <img class="modal-screenshot" id="modal-screenshot" src="" alt="Project screenshot" style="display: none;">
            <div>
                <a class="modal-button" id="modal-view-button" href="#" target="_blank">View Project ‚Üí</a>
                <button class="modal-button secondary" id="modal-close-button">Close</button>
            </div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- GLTFLoader for loading character model -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // ==============================================
        // PROJECT DATA - Easy to update!
        // ==============================================
        const projects = [
            {
                id: 1,
                title: "Neural Network Visualizer",
                description: "An interactive 3D visualization of neural network architectures with real-time training animation. Explore how data flows through layers and watch the network learn.",
                technologies: ["Three.js", "TensorFlow.js", "WebGL"],
                liveUrl: "https://example.com/neural-viz",
                thumbnail: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='300'%3E%3Crect fill='%231a1a2e' width='400' height='300'/%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' fill='%2300d4ff' font-size='24' font-family='Arial'%3ENeural Net%3C/text%3E%3C/svg%3E",
                monitorPosition: { x: -2.5, y: 1.1, z: -1.3 }  // Back left
            },
            {
                id: 2,
                title: "Particle Physics Sandbox",
                description: "A WebGL-powered particle physics playground where you can experiment with gravity, collision, and forces in real-time. Includes preset simulations and custom parameter controls.",
                technologies: ["WebGL", "GLSL", "JavaScript"],
                liveUrl: "https://example.com/particles",
                thumbnail: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='300'%3E%3Crect fill='%231a1a2e' width='400' height='300'/%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' fill='%2300d4ff' font-size='24' font-family='Arial'%3EParticles%3C/text%3E%3C/svg%3E",
                monitorPosition: { x: -1, y: 1.1, z: -1.3 }  // Back center-left
            },
            {
                id: 3,
                title: "Generative Art Gallery",
                description: "A curated collection of generative art pieces created with algorithms. Each piece is unique and generated in real-time using mathematical functions and random seeds.",
                technologies: ["Canvas API", "P5.js", "React"],
                liveUrl: "https://example.com/gen-art",
                thumbnail: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='300'%3E%3Crect fill='%231a1a2e' width='400' height='300'/%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' fill='%2300d4ff' font-size='24' font-family='Arial'%3EGen Art%3C/text%3E%3C/svg%3E",
                monitorPosition: { x: 1, y: 1.1, z: -1.3 }  // Back center-right
            },
            {
                id: 4,
                title: "Sound Wave Sculptor",
                description: "Create beautiful 3D forms from audio input. Upload music or use your microphone to generate real-time sculptural visualizations based on frequency and amplitude data.",
                technologies: ["Web Audio API", "Three.js", "Tone.js"],
                liveUrl: "https://example.com/sound-sculpt",
                thumbnail: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='300'%3E%3Crect fill='%231a1a2e' width='400' height='300'/%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' fill='%2300d4ff' font-size='24' font-family='Arial'%3ESound Wave%3C/text%3E%3C/svg%3E",
                monitorPosition: { x: 2.5, y: 1.1, z: -1.3 }  // Back right
            },
            {
                id: 5,
                title: "Shader Playground",
                description: "An interactive GLSL shader editor with live preview. Experiment with fragment and vertex shaders, explore preset effects, and create mesmerizing visual effects.",
                technologies: ["GLSL", "WebGL", "CodeMirror"],
                liveUrl: "https://example.com/shaders",
                thumbnail: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='300'%3E%3Crect fill='%231a1a2e' width='400' height='300'/%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' fill='%2300d4ff' font-size='24' font-family='Arial'%3EShaders%3C/text%3E%3C/svg%3E",
                monitorPosition: { x: -2.9, y: 1.1, z: 0.8 }  // Left side
            },
            {
                id: 6,
                title: "Fractal Explorer",
                description: "Dive deep into the infinite beauty of fractals. Navigate through Mandelbrot and Julia sets with smooth zooming, color customization, and high-resolution rendering.",
                technologies: ["WebGL", "GLSL", "TypeScript"],
                liveUrl: "https://example.com/fractals",
                thumbnail: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='300'%3E%3Crect fill='%231a1a2e' width='400' height='300'/%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' fill='%2300d4ff' font-size='24' font-family='Arial'%3EFractals%3C/text%3E%3C/svg%3E",
                monitorPosition: { x: 2.9, y: 1.1, z: 0.8 }  // Right side
            }
        ];

        // ==============================================
        // SCENE SETUP
        // ==============================================
        let scene, camera, renderer, controls;
        let monitors = [];
        let character;
        let raycaster, mouse;
        let hoveredMonitor = null;
        let selectedMonitorIndex = -1;
        let clock;

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2a3545); // Deep blue-grey
            scene.fog = new THREE.Fog(0x2a3545, 10, 50);

            // Camera - Over-the-shoulder perspective
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            // Position behind and to the right of character, at head level (character head at y‚âà1.9)
            camera.position.set(1.5, 2, -2);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Controls - loaded after Three.js
            loadOrbitControls();

            // Raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Clock for animations
            clock = new THREE.Clock();

            // Lighting
            setupLighting();

            // Load character FIRST, then create everything else based on its dimensions
            loadCharacterAndSetup();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('click', onMouseClick);
            window.addEventListener('keydown', onKeyDown);

            // Start animation
            animate();
        }

        function loadOrbitControls() {
            // OrbitControls - inline minimal version
            THREE.OrbitControls = function(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;

                this.enabled = true;
                this.target = new THREE.Vector3();

                this.minDistance = 5;
                this.maxDistance = 15;
                this.minPolarAngle = 0;
                this.maxPolarAngle = Math.PI / 2;

                this.enableDamping = true;
                this.dampingFactor = 0.05;

                this.rotateSpeed = 0.5;

                const scope = this;
                const spherical = new THREE.Spherical();
                const sphericalDelta = new THREE.Spherical();
                let scale = 1;

                const rotateStart = new THREE.Vector2();
                const rotateEnd = new THREE.Vector2();
                const rotateDelta = new THREE.Vector2();

                let state = -1;
                const STATE = { NONE: -1, ROTATE: 0 };

                function onMouseDown(event) {
                    if (!scope.enabled) return;
                    event.preventDefault();
                    rotateStart.set(event.clientX, event.clientY);
                    state = STATE.ROTATE;
                    scope.domElement.addEventListener('mousemove', onMouseMove);
                    scope.domElement.addEventListener('mouseup', onMouseUp);
                }

                function onMouseMove(event) {
                    if (!scope.enabled) return;
                    event.preventDefault();
                    rotateEnd.set(event.clientX, event.clientY);
                    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
                    const element = scope.domElement;
                    sphericalDelta.theta -= 2 * Math.PI * rotateDelta.x / element.clientHeight;
                    sphericalDelta.phi -= 2 * Math.PI * rotateDelta.y / element.clientHeight;
                    rotateStart.copy(rotateEnd);
                }

                function onMouseUp(event) {
                    if (!scope.enabled) return;
                    scope.domElement.removeEventListener('mousemove', onMouseMove);
                    scope.domElement.removeEventListener('mouseup', onMouseUp);
                    state = STATE.NONE;
                }

                function onMouseWheel(event) {
                    if (!scope.enabled) return;
                    event.preventDefault();
                    event.stopPropagation();
                    if (event.deltaY < 0) {
                        scale /= 0.95;
                    } else if (event.deltaY > 0) {
                        scale *= 0.95;
                    }
                }

                this.update = function() {
                    const offset = new THREE.Vector3();
                    const quat = new THREE.Quaternion().setFromUnitVectors(camera.up, new THREE.Vector3(0, 1, 0));
                    const quatInverse = quat.clone().invert();
                    const lastPosition = new THREE.Vector3();
                    const lastQuaternion = new THREE.Quaternion();

                    return function update() {
                        const position = scope.camera.position;
                        offset.copy(position).sub(scope.target);
                        offset.applyQuaternion(quat);
                        spherical.setFromVector3(offset);

                        if (scope.enableDamping) {
                            spherical.theta += sphericalDelta.theta * scope.dampingFactor;
                            spherical.phi += sphericalDelta.phi * scope.dampingFactor;
                            sphericalDelta.theta *= (1 - scope.dampingFactor);
                            sphericalDelta.phi *= (1 - scope.dampingFactor);
                        } else {
                            spherical.theta += sphericalDelta.theta;
                            spherical.phi += sphericalDelta.phi;
                            sphericalDelta.set(0, 0, 0);
                        }

                        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
                        spherical.makeSafe();
                        spherical.radius *= scale;
                        spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));

                        offset.setFromSpherical(spherical);
                        offset.applyQuaternion(quatInverse);
                        position.copy(scope.target).add(offset);
                        scope.camera.lookAt(scope.target);

                        scale = 1;

                        if (lastPosition.distanceToSquared(scope.camera.position) > 0.00001 ||
                            8 * (1 - lastQuaternion.dot(scope.camera.quaternion)) > 0.00001) {
                            lastPosition.copy(scope.camera.position);
                            lastQuaternion.copy(scope.camera.quaternion);
                            return true;
                        }
                        return false;
                    };
                }();

                this.domElement.addEventListener('mousedown', onMouseDown);
                this.domElement.addEventListener('wheel', onMouseWheel, { passive: false });
            };

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            // Target point at character head/monitor level
            controls.target.set(0, 0.5, -0.3);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 3;
            controls.maxDistance = 10;
            controls.maxPolarAngle = Math.PI / 2;
            controls.update();
        }

        function loadCharacterAndSetup() {
            const loader = new THREE.GLTFLoader();

            loader.load(
                './assets/character.glb',
                // Success callback - character loaded, now measure and build scene
                function(gltf) {
                    character = gltf.scene;

                    // MEASURE the character's actual dimensions
                    const box = new THREE.Box3().setFromObject(character);
                    const size = box.getSize(new THREE.Vector3());
                    const characterHeight = size.y;

                    console.log('Character loaded - Height:', characterHeight);

                    // CALCULATE all positions based on character
                    const deskHeight = characterHeight * 0.6;  // Desk at waist height
                    const deskSurfaceY = deskHeight + 0.1;     // Top of desk surface

                    console.log('Calculated desk height:', deskHeight);
                    console.log('Desk surface at:', deskSurfaceY);

                    // Scale character to proper size (needs to be larger than monitors/objects)
                    const targetHeight = 3.0;  // Increased from 1.8 to make character bigger
                    const scale = targetHeight / characterHeight;
                    character.scale.set(scale, scale, scale);

                    // Recalculate after scaling
                    const scaledHeight = targetHeight;
                    const finalDeskHeight = scaledHeight * 0.6;
                    const deskThickness = 0.05;  // Thinner desk
                    const finalDeskSurfaceY = finalDeskHeight + (deskThickness / 2);

                    console.log('After scaling - Character height:', scaledHeight);
                    console.log('Final desk height:', finalDeskHeight);
                    console.log('Final desk surface:', finalDeskSurfaceY);

                    // Position character on floor, rotate to face forward
                    character.position.set(0, 0, -0.5);
                    character.rotation.y = Math.PI;  // Rotate 180 degrees to face forward

                    // Enable shadows
                    character.traverse(function(node) {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                            if (node.material) {
                                node.material.roughness = Math.max(node.material.roughness || 0.5, 0.7);
                                node.material.metalness = Math.min(node.material.metalness || 0.1, 0.2);
                            }
                        }
                    });

                    scene.add(character);

                    // NO ANIMATIONS - character should be completely still
                    console.log('Character positioned on floor at y=0');

                    // Now create everything else based on calculated dimensions
                    createDesk(finalDeskHeight, deskThickness);
                    createMonitors(finalDeskSurfaceY);
                    createEnvironment(finalDeskSurfaceY);

                    // Update monitor positions in projects array
                    updateMonitorPositions(finalDeskSurfaceY);

                    // Hide loading screen
                    setTimeout(() => {
                        document.getElementById('loading-screen').classList.add('hidden');
                    }, 500);
                },
                // Progress callback
                function(xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                // Error callback - use fallback
                function(error) {
                    console.error('Error loading character model:', error);

                    if (window.location.protocol === 'file:') {
                        console.error('‚ùå CORS Error: Cannot load GLB files using file:// protocol');
                        console.info('üí° Solution: Run a local web server instead:');
                        console.info('   Option 1: python3 -m http.server 8000');
                        console.info('   Option 2: npx http-server');
                        console.info('   Then visit: http://localhost:8000/portfolio.html');
                    }

                    console.warn('Creating fallback placeholder character');
                    createFallbackCharacterAndSetup();
                }
            );
        }

        function createFallbackCharacterAndSetup() {
            // Fallback: Simple placeholder if GLB fails to load (scaled to 3.0 units tall)
            character = new THREE.Group();

            const bodyGeometry = new THREE.BoxGeometry(1.2, 1.8, 1.0);  // Scaled up
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x2d7f8f,
                roughness: 0.85,
                metalness: 0.0
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.9;  // Half of body height
            body.castShadow = true;
            character.add(body);

            const headGeometry = new THREE.SphereGeometry(0.65, 16, 16);  // Scaled up
            const headMaterial = new THREE.MeshStandardMaterial({
                color: 0xffcfa0,
                roughness: 0.9,
                metalness: 0.0
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.4;  // Body height (1.8) + head radius (0.65) - slight overlap
            head.castShadow = true;
            character.add(head);

            character.position.set(0, 0, -0.5);
            character.rotation.y = Math.PI;  // Face forward
            scene.add(character);

            character.userData.head = head;
            character.userData.body = body;

            // Calculate based on fallback character dimensions (make it bigger - 3.0 units)
            const characterHeight = 3.0;  // Increased from 1.4
            const deskHeight = characterHeight * 0.6;
            const deskThickness = 0.05;  // Thinner desk
            const deskSurfaceY = deskHeight + (deskThickness / 2);

            console.log('Fallback character created - height:', characterHeight);
            console.log('Desk height:', deskHeight, 'Surface:', deskSurfaceY);

            // Create scene with calculated dimensions
            createDesk(deskHeight, deskThickness);
            createMonitors(deskSurfaceY);
            createEnvironment(deskSurfaceY);
            updateMonitorPositions(deskSurfaceY);

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading-screen').classList.add('hidden');
            }, 500);
        }

        function updateMonitorPositions(deskSurfaceY) {
            // Update all monitor Y positions in projects array
            projects.forEach(project => {
                project.monitorPosition.y = deskSurfaceY;
            });
            console.log('Monitor positions updated to y =', deskSurfaceY);
        }

        function setupLighting() {
            // Ambient light for overall illumination - increased brightness
            const ambientLight = new THREE.AmbientLight(0x5a5a7a, 1.2);
            scene.add(ambientLight);

            // Key light (main light source)
            const keyLight = new THREE.DirectionalLight(0xffffff, 1.5);
            keyLight.position.set(5, 8, 5);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 2048;
            keyLight.shadow.mapSize.height = 2048;
            keyLight.shadow.camera.near = 0.5;
            keyLight.shadow.camera.far = 50;
            keyLight.shadow.camera.left = -10;
            keyLight.shadow.camera.right = 10;
            keyLight.shadow.camera.top = 10;
            keyLight.shadow.camera.bottom = -10;
            scene.add(keyLight);

            // Fill light (softer, from the side)
            const fillLight = new THREE.PointLight(0x4080ff, 0.8);
            fillLight.position.set(-5, 3, 3);
            scene.add(fillLight);

            // Accent light (warm glow)
            const accentLight = new THREE.PointLight(0xffaa00, 0.7);
            accentLight.position.set(0, 2, -3);
            scene.add(accentLight);

            // Rim light for monitors
            const rimLight = new THREE.PointLight(0x00d4ff, 1.0);
            rimLight.position.set(0, 2, 2);
            scene.add(rimLight);
        }

        function createDesk(deskHeight, deskThickness) {
            // L-shaped desk at calculated waist height - elevated above blue floor
            // deskThickness passed as parameter (much thinner now)

            const deskMaterial = new THREE.MeshStandardMaterial({
                color: 0xd4915a, // Warm wood/beige tone
                roughness: 0.85,
                metalness: 0.0
            });

            // Back section (behind character)
            const backDeskGeometry = new THREE.BoxGeometry(6, deskThickness, 1.2);
            const backDesk = new THREE.Mesh(backDeskGeometry, deskMaterial);
            backDesk.position.set(0, deskHeight, -1.3);
            backDesk.receiveShadow = true;
            backDesk.castShadow = true;
            scene.add(backDesk);

            // Left arm (wrapping around left side)
            const leftDeskGeometry = new THREE.BoxGeometry(1.2, deskThickness, 3.5);
            const leftDesk = new THREE.Mesh(leftDeskGeometry, deskMaterial);
            leftDesk.position.set(-2.9, deskHeight, 0.45);
            leftDesk.receiveShadow = true;
            leftDesk.castShadow = true;
            scene.add(leftDesk);

            // Right arm (wrapping around right side)
            const rightDeskGeometry = new THREE.BoxGeometry(1.2, deskThickness, 3.5);
            const rightDesk = new THREE.Mesh(rightDeskGeometry, deskMaterial);
            rightDesk.position.set(2.9, deskHeight, 0.45);
            rightDesk.receiveShadow = true;
            rightDesk.castShadow = true;
            scene.add(rightDesk);

            // Front section (connecting the arms in front of character)
            const frontDeskGeometry = new THREE.BoxGeometry(3.4, deskThickness, 1.2);
            const frontDesk = new THREE.Mesh(frontDeskGeometry, deskMaterial);
            frontDesk.position.set(0, deskHeight, 1.6);
            frontDesk.receiveShadow = true;
            frontDesk.castShadow = true;
            scene.add(frontDesk);

            // Desk legs for L-shaped desk
            const legGeometry = new THREE.CylinderGeometry(0.08, 0.08, deskHeight);
            const legMaterial = new THREE.MeshStandardMaterial({
                color: 0xa87242, // Darker wood
                roughness: 0.9,
                metalness: 0.0
            });

            const legPositions = [
                // Back corners
                [-2.8, deskHeight / 2, -1.8],
                [2.8, deskHeight / 2, -1.8],
                // Front corners (left side)
                [-3.4, deskHeight / 2, 2.1],
                // Front corners (right side)
                [3.4, deskHeight / 2, 2.1],
                // Middle support legs
                [-2.2, deskHeight / 2, 0.5],
                [2.2, deskHeight / 2, 0.5]
            ];

            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(...pos);
                leg.castShadow = true;
                scene.add(leg);
            });

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(30, 30);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x3d4e5f, // Deep blue-grey
                roughness: 0.95,
                metalness: 0.0
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
        }

        function createMonitors(deskSurfaceY) {
            // Monitors rest on calculated desk surface height
            projects.forEach((project, index) => {
                const monitor = createMonitor(project);
                monitor.userData = {
                    projectId: project.id,
                    projectIndex: index,
                    originalY: deskSurfaceY,  // Monitors rest on desk surface
                    isHovered: false
                };
                monitors.push(monitor);
                scene.add(monitor);
            });
        }

        function createMonitor(project) {
            const monitor = new THREE.Group();

            // Monitor stand
            const standGeometry = new THREE.CylinderGeometry(0.05, 0.08, 0.3, 8);
            const standMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a4a5a, // Dark blue-grey
                roughness: 0.75,
                metalness: 0.15
            });
            const stand = new THREE.Mesh(standGeometry, standMaterial);
            stand.position.y = 0.15;
            stand.castShadow = true;
            monitor.add(stand);

            // Monitor frame
            const frameGeometry = new THREE.BoxGeometry(0.8, 0.5, 0.05);
            const frameMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a3a4a, // Deep blue
                roughness: 0.7,
                metalness: 0.2
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.y = 0.5;
            frame.castShadow = true;
            monitor.add(frame);

            // Monitor screen (this will show the project thumbnail)
            const screenGeometry = new THREE.PlaneGeometry(0.7, 0.4);

            // Load texture
            const textureLoader = new THREE.TextureLoader();
            const texture = textureLoader.load(project.thumbnail);

            const screenMaterial = new THREE.MeshStandardMaterial({
                map: texture,
                emissive: 0x00d4ff,
                emissiveIntensity: 0.3,
                roughness: 0.2,
                metalness: 0.5
            });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.set(0, 0.5, 0.026);
            monitor.add(screen);

            // Glow effect (hidden by default)
            const glowGeometry = new THREE.PlaneGeometry(0.75, 0.45);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x00d4ff,
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.set(0, 0.5, 0.027);
            monitor.add(glow);

            // Position monitor on desk surface using project data
            monitor.position.set(
                project.monitorPosition.x,
                project.monitorPosition.y,  // Monitors rest on desk surface
                project.monitorPosition.z
            );

            // Rotate monitor to face character position (0, 0.5, -0.5)
            const characterPos = new THREE.Vector3(0, 0.5, -0.5);
            monitor.lookAt(characterPos);

            // Store references for animation
            monitor.userData.screen = screen;
            monitor.userData.glow = glow;
            monitor.userData.frame = frame;

            return monitor;
        }

        function createEnvironment(deskSurfaceY) {
            // Use calculated desk surface height for all objects

            // Keyboard directly in front of character
            const keyboardGeometry = new THREE.BoxGeometry(0.6, 0.05, 0.3);
            const keyboardMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a5a6a, // Dark blue-grey
                roughness: 0.8,
                metalness: 0.1
            });
            const keyboard = new THREE.Mesh(keyboardGeometry, keyboardMaterial);
            keyboard.position.set(0, deskSurfaceY + 0.025, 0.2);
            keyboard.castShadow = true;
            scene.add(keyboard);

            // Mouse and mousepad to the right
            const mousepadGeometry = new THREE.BoxGeometry(0.25, 0.01, 0.3);
            const mousepadMaterial = new THREE.MeshStandardMaterial({
                color: 0x2d4a5a, // Deep teal-blue
                roughness: 0.95
            });
            const mousepad = new THREE.Mesh(mousepadGeometry, mousepadMaterial);
            mousepad.position.set(0.7, deskSurfaceY + 0.005, 0.2);
            mousepad.castShadow = true;
            scene.add(mousepad);

            const mouseGeometry = new THREE.BoxGeometry(0.08, 0.04, 0.12);
            const mouseMaterial = new THREE.MeshStandardMaterial({
                color: 0x5a6a7a, // Medium grey-blue
                roughness: 0.7,
                metalness: 0.1
            });
            const mouse = new THREE.Mesh(mouseGeometry, mouseMaterial);
            mouse.position.set(0.7, deskSurfaceY + 0.025, 0.2);
            mouse.castShadow = true;
            scene.add(mouse);

            // Notebook on left side of desk
            const notebookGeometry = new THREE.BoxGeometry(0.35, 0.02, 0.45);
            const notebookMaterial = new THREE.MeshStandardMaterial({
                color: 0xc67f3a, // Warm orange-brown
                roughness: 0.95
            });
            const notebook = new THREE.Mesh(notebookGeometry, notebookMaterial);
            notebook.position.set(-2.3, deskSurfaceY + 0.01, 0.5);
            notebook.rotation.y = -0.3;
            notebook.castShadow = true;
            scene.add(notebook);

            // Pen on notebook
            const penGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.15, 6);
            const penMaterial = new THREE.MeshStandardMaterial({
                color: 0x2d5f7f, // Deep teal
                roughness: 0.6,
                metalness: 0.2
            });
            const pen = new THREE.Mesh(penGeometry, penMaterial);
            pen.position.set(-2.2, deskSurfaceY + 0.03, 0.6);
            pen.rotation.z = Math.PI / 2;
            pen.rotation.y = 0.5;
            pen.castShadow = true;
            scene.add(pen);

            // Coffee cup on right side of desk
            const cupGroup = new THREE.Group();

            const cupGeometry = new THREE.CylinderGeometry(0.1, 0.08, 0.15, 16);
            const cupMaterial = new THREE.MeshStandardMaterial({
                color: 0xe8d4bf, // Warm cream
                roughness: 0.85,
                metalness: 0.0
            });
            const cup = new THREE.Mesh(cupGeometry, cupMaterial);
            cup.castShadow = true;
            cupGroup.add(cup);

            const coffeeGeometry = new THREE.CircleGeometry(0.09, 16);
            const coffeeMaterial = new THREE.MeshStandardMaterial({
                color: 0x6f3a1a, // Warm brown
                roughness: 0.95
            });
            const coffee = new THREE.Mesh(coffeeGeometry, coffeeMaterial);
            coffee.rotation.x = -Math.PI / 2;
            coffee.position.y = 0.076;
            cupGroup.add(coffee);

            cupGroup.position.set(2.3, deskSurfaceY + 0.075, 0.5);
            scene.add(cupGroup);

            // Small plant on back desk
            const potGeometry = new THREE.CylinderGeometry(0.12, 0.1, 0.15, 16);
            const potMaterial = new THREE.MeshStandardMaterial({
                color: 0xc85f3a, // Terracotta orange
                roughness: 0.9
            });
            const pot = new THREE.Mesh(potGeometry, potMaterial);
            pot.position.set(0, deskSurfaceY + 0.075, -1.1);
            pot.castShadow = true;
            scene.add(pot);

            const leafGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const leafMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a7f3a, // Warm green
                roughness: 0.95
            });
            const leaves = new THREE.Mesh(leafGeometry, leafMaterial);
            leaves.scale.set(1, 1.5, 1);
            leaves.position.set(0, deskSurfaceY + 0.27, -1.1);
            leaves.castShadow = true;
            scene.add(leaves);
        }

        // ==============================================
        // ANIMATION & INTERACTION
        // ==============================================
        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();

            // NO character animations - character should be completely still

            // Fallback character idle animation (for placeholder character only)
            if (character && character.userData.head && character.userData.body) {
                // Gentle breathing (updated for scaled character)
                character.userData.body.position.y = 0.9 + Math.sin(elapsedTime * 2) * 0.04;
                character.userData.head.position.y = 2.4 + Math.sin(elapsedTime * 2) * 0.04;

                // Subtle head tilt
                character.userData.head.rotation.y = Math.sin(elapsedTime * 0.5) * 0.1;
                character.userData.head.rotation.z = Math.sin(elapsedTime * 0.3) * 0.05;
            }

            // Monitor hover animations
            monitors.forEach(monitor => {
                // Skip if monitor or required properties don't exist
                if (!monitor || !monitor.userData || !monitor.userData.glow || !monitor.userData.screen) {
                    return;
                }

                const targetY = monitor.userData.isHovered ?
                    monitor.userData.originalY + 0.1 :
                    monitor.userData.originalY;

                monitor.position.y += (targetY - monitor.position.y) * 0.1;

                const targetGlowOpacity = monitor.userData.isHovered ? 0.4 : 0;
                monitor.userData.glow.material.opacity +=
                    (targetGlowOpacity - monitor.userData.glow.material.opacity) * 0.1;

                const targetEmissive = monitor.userData.isHovered ? 0.5 : 0.3;
                monitor.userData.screen.material.emissiveIntensity +=
                    (targetEmissive - monitor.userData.screen.material.emissiveIntensity) * 0.1;
            });

            // Update controls
            if (controls) controls.update();

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update raycaster
            raycaster.setFromCamera(mouse, camera);

            // Check for intersections with monitors
            const intersects = raycaster.intersectObjects(monitors, true);

            // Reset all hover states
            monitors.forEach(monitor => {
                monitor.userData.isHovered = false;
            });

            // Set hover state for intersected monitor
            if (intersects.length > 0) {
                let object = intersects[0].object;
                while (object.parent && !monitors.includes(object.parent)) {
                    object = object.parent;
                }
                if (object.parent && monitors.includes(object.parent)) {
                    object.parent.userData.isHovered = true;
                    document.body.style.cursor = 'pointer';
                    hoveredMonitor = object.parent;
                } else {
                    document.body.style.cursor = 'default';
                    hoveredMonitor = null;
                }
            } else {
                document.body.style.cursor = 'default';
                hoveredMonitor = null;
            }
        }

        function onMouseClick(event) {
            // Don't trigger if clicking on modal
            if (event.target.closest('#modal-overlay')) return;

            if (hoveredMonitor) {
                const projectIndex = hoveredMonitor.userData.projectIndex;
                openModal(projectIndex);
            }
        }

        function onKeyDown(event) {
            // Tab key for navigation
            if (event.key === 'Tab') {
                event.preventDefault();
                selectedMonitorIndex = (selectedMonitorIndex + 1) % monitors.length;

                // Reset all hover states
                monitors.forEach(monitor => {
                    monitor.userData.isHovered = false;
                });

                // Set selected monitor as hovered
                monitors[selectedMonitorIndex].userData.isHovered = true;
                hoveredMonitor = monitors[selectedMonitorIndex];
            }

            // Enter key to open modal
            if (event.key === 'Enter' && hoveredMonitor) {
                const projectIndex = hoveredMonitor.userData.projectIndex;
                openModal(projectIndex);
            }

            // Escape key to close modal
            if (event.key === 'Escape') {
                closeModal();
            }
        }

        // ==============================================
        // MODAL SYSTEM
        // ==============================================
        function openModal(projectIndex) {
            const project = projects[projectIndex];

            // Populate modal
            document.getElementById('modal-title').textContent = project.title;
            document.getElementById('modal-description').textContent = project.description;
            document.getElementById('modal-view-button').href = project.liveUrl;

            // Add technology tags
            const techTagsContainer = document.getElementById('modal-tech-tags');
            techTagsContainer.innerHTML = '';
            project.technologies.forEach(tech => {
                const tag = document.createElement('span');
                tag.className = 'tech-tag';
                tag.textContent = tech;
                techTagsContainer.appendChild(tag);
            });

            // Show/hide screenshot
            const screenshot = document.getElementById('modal-screenshot');
            if (project.screenshot) {
                screenshot.src = project.screenshot;
                screenshot.style.display = 'block';
            } else {
                screenshot.style.display = 'none';
            }

            // Show modal
            const modalOverlay = document.getElementById('modal-overlay');
            modalOverlay.classList.add('active');

            // Disable controls while modal is open
            if (controls) controls.enabled = false;
        }

        function closeModal() {
            const modalOverlay = document.getElementById('modal-overlay');
            modalOverlay.classList.remove('active');

            // Re-enable controls
            if (controls) controls.enabled = true;

            // Reset hover state
            monitors.forEach(monitor => {
                monitor.userData.isHovered = false;
            });
            hoveredMonitor = null;
            selectedMonitorIndex = -1;
        }

        // Modal close button handlers
        document.getElementById('modal-close').addEventListener('click', closeModal);
        document.getElementById('modal-close-button').addEventListener('click', closeModal);
        document.getElementById('modal-overlay').addEventListener('click', function(event) {
            if (event.target === this) {
                closeModal();
            }
        });

        // ==============================================
        // INITIALIZE
        // ==============================================
        init();
    </script>
</body>
</html>